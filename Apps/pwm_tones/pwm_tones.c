/*
 * Copyright 2014, Broadcom Corporation
 * All Rights Reserved.
 *
 * This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;
 * the contents of this file may not be disclosed to third parties, copied
 * or duplicated in any form, in whole or in part, without the prior
 * written permission of Broadcom Corporation.
 */

/** @file
*
* PWM Tones Sample
*
* This application provides the sample code that uses the
* on-chip PWM and the buzzer on the TAG board to cycle
* through different tones when the button connected to P0
* is pressed. It also uses two other channels to generate
* random width pulses. Tones are generated with a 50% duty
* cycle and the other two channels have some randomness.
*
* Features demonstrated
*  - Use of the PWM driver interface
*  - Using PWM3 on P13.
*  - Use of the on-chip HW random number generator.
*  - Using J-Link and GDB for debugging.
*
* To demonstrate the app, work through the following steps.
* 1. Plug the WICED eval board into your computer
* 2. Build and download the application (to the WICED board)
* 3. Once the application is running, push SW1 and every
* 	time the button is pressed, the tone generated by the buzzer
* 	will cycle through a set of frequencies.
* 4. Attach an oscilloscope to P13 and P27 to see random width
* 	signals.
*
* To debug, add DEBUG=1 to this application's make target in the IDE.
* Then hook up J-Link to J10 on the tag board. You will need J-Link
* GDB server, J-Link Commander and J-Link (Base version is sufficient).
* Once you download the application from the IDE, start J-Link GBD server
* and then from the debug menu, choose WICED Smart debug configuration.
* This will start GDB client which will connect to the GDB server and
* start a debug session. Make sure that when starting J-Link GDB server,
* you have have the following configurations:
* Target device = Cortex-M3, Little endian
* Target interface = SWD
* Speed = 1000 kHz
* Init regs on start = unchecked
* 
* KNOWN ISSUE: Eclipse will not be able to halt the CPU sometimes. Open
* J-Link commander and wait for it to connect. Once it establishes a
* connection with the debug HW block, type 'halt', without the quites
* in the commander window and Eclipse will regain control of the CPU.
*/
#define CONFIG_IN_NVRAM 1
#include "bleprofile.h"
#include "bleapp.h"
#include "gpiodriver.h"
#include "string.h"
#include "stdio.h"
#include "platform.h"
#include "bleappconfig.h"
#include "cfa.h"
#include "spar_utils.h"
// To use PWM, we will need the auxiliary clock and the PWM drier.
#include "aclk.h"
#include "pwm.h"

/******************************************************
 *                      Constants
 ******************************************************/
// The GPIO to which an LED is assumed to be connected. Note that
// the tag board does not have an LED connected to P26 by default.
// To observe the behavior, hook up an oscilloscope to P13.
#define TONES_LED1_GPIO       (13)

/******************************************************
 *               Types
 ******************************************************/
enum
{
	TONES_STATE_0,
	TONES_STATE_1,
	TONES_STATE_2,
	TONES_STATE_3,
	TONES_STATE_4
};
/******************************************************
 *               Function Prototypes
 ******************************************************/
static void tones_create(void);
static void tones_timeout(UINT32 arg);
static void tones_fine_timeout(UINT32 arg);
static void tones_button_interrupt_handler(UINT8 value);
static void tones_play_tone(void);
static void tones_go_to_next_state(void);
static void tones_blink_led1(void);
/******************************************************
 *               Variables Definitions
 ******************************************************/
UINT8 tones_current_state = TONES_STATE_4;

/*
 * This is the GATT database for the Temperature Sensor application.  It is
 * currently empty with only required GAP and GATT services.
 */
const UINT8 tones_gatt_database[]=
{
    // Handle 0x01: GATT service
    // Service change characteristic is optional and is not present
    PRIMARY_SERVICE_UUID16 (0x0001, UUID_SERVICE_GATT),

    // Handle 0x14: GAP service
    // Device Name and Appearance are mandatory characteristics.  Peripheral
    // Privacy Flag only required if privacy feature is supported.  Reconnection
    // Address is optional and only when privacy feature is supported.
    // Peripheral Preferred Connection Parameters characteristic is optional
    // and not present.
    PRIMARY_SERVICE_UUID16 (0x0014, UUID_SERVICE_GAP),

    // Handle 0x15: characteristic Device Name, handle 0x16 characteristic value.
    // Any 16 byte string can be used to identify the sensor.  Just need to
    // replace the "Tones" string below.
    CHARACTERISTIC_UUID16 (0x0015, 0x0016, UUID_CHARACTERISTIC_DEVICE_NAME,
                                           LEGATTDB_CHAR_PROP_READ, LEGATTDB_PERM_READABLE, 16),
       'P','W','M',' ','T','o','n','e','s',0x00,0x00,0x00,0x00,0x00,0x00,0x00,

    // Handle 0x17: characteristic Appearance, handle 0x18 characteristic value.
    // List of approved appearances is available at bluetooth.org.  Current
    // value is set to 0x200 - Generic Tag
    CHARACTERISTIC_UUID16 (0x0017, 0x0018, UUID_CHARACTERISTIC_APPEARANCE,
                                           LEGATTDB_CHAR_PROP_READ, LEGATTDB_PERM_READABLE, 2),
        0x00,0x02,

};

/*
 * This is the application configuration.
 * */
const BLE_PROFILE_CFG tones_cfg =
{
        /*.fine_timer_interval            =*/ 1000, // ms
        /*.default_adv                    =*/ NO_DISCOVERABLE, // current sensor is not discoverable
        /*.button_adv_toggle              =*/ 0,    // pairing button make adv toggle (if 1) or always on (if 0)
        /*.high_undirect_adv_interval     =*/ 32,   // slots
        /*.low_undirect_adv_interval      =*/ 1024, // slots
        /*.high_undirect_adv_duration     =*/ 30,   // seconds
        /*.low_undirect_adv_duration      =*/ 300,  // seconds
        /*.high_direct_adv_interval       =*/ 0,    // seconds
        /*.low_direct_adv_interval        =*/ 0,    // seconds
        /*.high_direct_adv_duration       =*/ 0,    // seconds
        /*.low_direct_adv_duration        =*/ 0,    // seconds
        /*.local_name                     =*/ "PWM Tones",  // [LOCAL_NAME_LEN_MAX];
        /*.cod                            =*/ "\x00\x00\x00", // [COD_LEN];
        /*.ver                            =*/ "1.00",         // [VERSION_LEN];
        /*.encr_required                  =*/ 0,    // data encrypted and device sends security request on every connection
        /*.disc_required                  =*/ 0,    // if 1, disconnection after confirmation
        /*.test_enable                    =*/ 1,    // TEST MODE is enabled when 1
        /*.tx_power_level                 =*/ 0x04, // dbm
        /*.con_idle_timeout               =*/ 3,    // second  0-> no timeout
        /*.powersave_timeout              =*/ 0,    // second  0-> no timeout
        /*.hdl                            =*/ {0x00, 0x00, 0x00, 0x00, 0x00}, // [HANDLE_NUM_MAX];
        /*.serv                           =*/ {0x00, 0x00, 0x00, 0x00, 0x00},
        /*.cha                            =*/ {0x00, 0x00, 0x00, 0x00, 0x00},
        /*.findme_locator_enable          =*/ 0,    // if 1 Find me locator is enable
        /*.findme_alert_level             =*/ 0,    // alert level of find me
        /*.client_grouptype_enable        =*/ 0,    // if 1 grouptype read can be used
        /*.linkloss_button_enable         =*/ 0,    // if 1 linkloss button is enable
        /*.pathloss_check_interval        =*/ 0,    // second
        /*.alert_interval                 =*/ 0,    // interval of alert
        /*.high_alert_num                 =*/ 0,    // number of alert for each interval
        /*.mild_alert_num                 =*/ 0,    // number of alert for each interval
        /*.status_led_enable              =*/ 0,    // if 1 status LED is enable
        /*.status_led_interval            =*/ 0,    // second
        /*.status_led_con_blink           =*/ 0,    // blink num of connection
        /*.status_led_dir_adv_blink       =*/ 0,    // blink num of dir adv
        /*.status_led_un_adv_blink        =*/ 0,    // blink num of undir adv
        /*.led_on_ms                      =*/ 0,    // led blink on duration in ms
        /*.led_off_ms                     =*/ 0,    // led blink off duration in ms
        /*.buz_on_ms                      =*/ 0,    // buzzer on duration in ms
        /*.button_power_timeout           =*/ 0,    // seconds
        /*.button_client_timeout          =*/ 0,    // seconds
        /*.button_discover_timeout        =*/ 0,    // seconds
        /*.button_filter_timeout          =*/ 0,    // seconds
    #ifdef BLE_UART_LOOPBACK_TRACE
        /*.button_uart_timeout            =*/ 15,   // seconds
    #endif
};

// Following structure defines UART configuration
const BLE_PROFILE_PUART_CFG tones_puart_cfg =
{
    /*.baudrate   =*/ 115200,
    /*.txpin      =*/ GPIO_PIN_UART_TX,
    /*.rxpin      =*/ GPIO_PIN_UART_RX,
};

// Following structure defines GPIO configuration used by the application
const BLE_PROFILE_GPIO_CFG tones_gpio_cfg =
{
    /*.gpio_pin =*/
    {
        GPIO_PIN_WP,      // This need to be used to enable/disable NVRAM write protect
        GPIO_PIN_BUTTON,  // Button GPIO is configured to trigger either direction of interrupt
        GPIO_PIN_LED,     // LED GPIO, optional to provide visual effects
        GPIO_PIN_BATTERY, // Battery monitoring GPIO. When it is lower than particular level, it will give notification to the application
        -1,-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 // other GPIOs are not used
    },
    /*.gpio_flag =*/
    {
        GPIO_SETTINGS_WP,
        GPIO_SETTINGS_BUTTON,
        GPIO_SETTINGS_LED,
        GPIO_SETTINGS_BATTERY,
        0,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    }
};

/******************************************************
 *               Function Definitions
 ******************************************************/

// Application initialization
APPLICATION_INIT()
{
    bleapp_set_cfg((UINT8 *)tones_gatt_database,
                   sizeof(tones_gatt_database),
                   (void *)&tones_cfg,
                   (void *)&tones_puart_cfg,
                   (void *)&tones_gpio_cfg,
                   tones_create);

	// Enable debugging in the HW.
    SETUP_APP_FOR_DEBUG_IF_DEBUG_ENABLED();
	
	// Busy wait till the debugger connects and you manyally set the CPU
	// continue from here. This will make it easier to step through
	// application initialization sequence.
	// To continue from here, add spar_debug_continue to the expressions
	// window in Eclipse. This will be 0x00. Change this to some non-zero
	// value and then hit continue.
    BUSY_WAIT_TILL_MANUAL_CONTINUE_IF_DEBUG_ENABLED();
}

// Create temperature sensor
void tones_create(void)
{
    extern UINT32 blecm_configFlag;
	
	// Set up HW for debugging again.
    SETUP_APP_FOR_DEBUG_IF_DEBUG_ENABLED();
	
	// Optionally wait till manually told to go.
    // BUSY_WAIT_TILL_MANUAL_CONTINUE_IF_DEBUG_ENABLED();

    blecm_configFlag |= BLECM_DBGUART_LOG;

    ble_trace0("tones_create()\n");

    // dump the database to debug uart.
    legattdb_dumpDb();

    bleprofile_Init(bleprofile_p_cfg);
    bleprofile_GPIOInit(bleprofile_gpio_p_cfg);

    // register interrupt handler for button inputs.
    bleprofile_regIntCb((BLEPROFILE_SINGLE_PARAM_CB) tones_button_interrupt_handler);

    bleprofile_regTimerCb(tones_fine_timeout, tones_timeout);
    bleprofile_StartTimer();

    // Configure auxiliary clock 1 (needed for PWM when using PMU_CLK; not needed
    // when reference is LHL_CLK) and use the 24MHz system
    // clock as the reference. Since we will generating up to 8KHz in this
    // sample app, feeding a 512K signal to the PWM as the reference should give
    // us sufficient accuracy. For higher accuracy, use a higher reference
    // frequency. Typically, for LEDs, we use lower PWM frequency and lower
    // reference frequencies.
    aclk_configure(512000, ACLK1, ACLK_FREQ_24_MHZ);

    // Switch to the next state.
    tones_go_to_next_state();

    // Start playing a tone.
    tones_play_tone();

    // Blink LED1.
    tones_blink_led1();
}


// One second timer expired.
void tones_timeout(UINT32 arg)
{
	// Not used.
}

// Fine timer callback.
void tones_fine_timeout(UINT32 arg)
{
	// Not used
}

// Three Interrupt inputs (Buttons) can be handled here.
// If the following value == 1, Button is pressed. Different than initial value.
// If the following value == 0, Button is depressed. Same as initial value.
// Button1 : value&0x01
// Button2 : (value&0x02)>>1
// Button3 : (value&0x04)>>2
void tones_button_interrupt_handler(UINT8 value)
{
	// On press.
	if (value & 1)
	{
		BLEPROFILE_DB_PDU db_pdu;

		ble_trace3("(INT)But1:%d But2:%d But3:%d\n", value&0x01, (value& 0x02) >> 1, (value & 0x04) >> 2);

		// Blink twice
		bleprofile_LEDBlink(250, 250, 2);

		tones_go_to_next_state();

		tones_play_tone();

		tones_blink_led1();
	}
}

// Plays the tone at the current frequency.
void tones_play_tone(void)
{
	switch(tones_current_state)
	{
		case TONES_STATE_0:
			// PWM channel 2 is P28 and the buzzer is connected to P28
			// This will give us ~1.017KHz
			pwm_start(PWM2, PMU_CLK, 0x2FF, 0x200);
			break;
		case TONES_STATE_1:
			// This will give us ~2.04KHz.
			pwm_start(PWM2, PMU_CLK, 0x37F, 0x300);
			break;
		case TONES_STATE_2:
			// This will give us ~3.05KHz
			pwm_start(PWM2, PMU_CLK, 0x3AA, 0x355);
			break;
		case TONES_STATE_3:
			// This will give us ~4.01KHz.
			pwm_start(PWM2, PMU_CLK, 0x3BF, 0x37E);
			break;
		case TONES_STATE_4:
			// This will give us ~8.03KHz.
			pwm_start(PWM2, PMU_CLK, 0x3E0, 0x3BF);
			break;
		default:
			break;
	}

	// Get init and toggle counts for Buzzer and trace it.
	ble_trace2("Buzzer init count: 0x%03X, Toggle Count: 0x%03X\n", pwm_getInitValue(PWM2), pwm_getToggleCount(PWM2));

    // Output enable the buzzer GPIO.
    gpio_configurePin((GPIO_PIN_BUZZER) / 16, (GPIO_PIN_BUZZER) % 16, PWM2_OUTPUT_ENABLE_P28, 0);
}

// Sets the state machine to the next state.
void tones_go_to_next_state(void)
{
	tones_current_state++;

	if (tones_current_state > TONES_STATE_4)
		tones_current_state = TONES_STATE_0;
}


// Blinks LEDs using some random values
void tones_blink_led1(void)
{
	// Generates a random number of length (in units of UINT32s) into buffer.
	extern void ulp_rand(UINT32* buffer, UINT32 length);
	UINT32 rand1, rand2, init_value, toggle_value;
	static ref_clock = 0;

	ulp_rand(&rand1, 1);
	ulp_rand(&rand2, 1);

	// The max count all PWM channels can count up to is 0x3FF.
	// So truncate both random numbers to 10 bits.
	rand1 &= (0x3FF);
	rand2 &= (0x3FF);

	if (rand1 > rand2)
	{
		init_value = rand2;
		toggle_value = rand1;
	}
	else
	{
		init_value = rand1;
		toggle_value = rand2;
	}

	// This may be possible.
	if (rand1 == rand2)
	{
		// Oops?
		init_value = 0;
		toggle_value = 0x3FF / 2;
	}

	switch(tones_current_state)
	{
		case TONES_STATE_0:
			// In state 0, start the PWM and output enable the GPIO
			// Use LHL_CLK instead of PMU_CLK so it will continue to run in sleep.
			pwm_start(PWM3, LHL_CLK, toggle_value, init_value);

			gpio_configurePin((TONES_LED1_GPIO) / 16, (TONES_LED1_GPIO) % 16, PWM3_OUTPUT_ENABLE_P13, 0);
			break;
		case TONES_STATE_1:
			// In state 1, switch to another set of values. Transition is not glitch-free.
			pwm_transitionToSubstituteValues(PWM3, toggle_value, init_value);
			break;
		case TONES_STATE_2:
			// In state 2, invert the output.
			pwm_setInversion(PWM3, TRUE);
			break;
		case TONES_STATE_3:
			// In state 3, use another set of values. Transition is glitch-free
			pwm_startWithAlternateValues(PWM3, LHL_CLK, toggle_value, init_value, TRUE);
			break;
		case TONES_STATE_4:
			// In state 4, disable output and the PWM entirely and insert an internal pull-down on the GPIO.
			gpio_configurePin((TONES_LED1_GPIO) / 16, (TONES_LED1_GPIO) % 16, GPIO_OUTPUT_DISABLE | GPIO_PULL_DOWN, 0);

			// Disable the channel.
			pwm_setReset(PWM3, 1);
			break;
		default:
			break;
	}

	// Get init and toggle counts for LED and trace it.
	ble_trace2("LED init count: 0x%03X, Toggle Count: 0x%03X\n", pwm_getInitValue(PWM3), pwm_getToggleCount(PWM3));
}

