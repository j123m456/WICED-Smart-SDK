/** @file
 *
 * This file has been automatically generated by the WICED Smart Designer. 
 * Device configuration and functions required for the BLE device.
 *
 */
 
/** @file
*
* Location and Navigation profile, service, application
*
* Refer to Bluetooth SIG Location and Navigation Profile 1.0 and Location
* and Navigation Service 1.0 specifications for details.
*
* This sample implements Location and Navigation Sensor.  During
* initialization the app registers with LE stack to receive various
* notifications including bonding complete, connection status change
* and peer writes.  Bonded device can write into client configuration
* descriptor to receive notifications with Location and Speed or Navigation.
* When data is received (for example over fake UART), app
* checks if there is an active registration and sends Notifications.  App
* also shows logic for processing commands received through the SC control
* point.
*
* Features demonstrated
*  - GATT database and Device configuration initialization
*  - Registration with LE stack for various events
*  - NVRAM read/write operation
*  - Processing control and data from the client
*  - Sending data to the client
*  - Support for connection parameters update
*  - Serializing events
*
* To demonstrate the app, work through the following steps.
* 1. Plug the WICED eval board into your computer
* 2. Build and download the application (to the WICED board)
* 3. Pair with a client
*
*/

#include "bleprofile.h"
#include "bleapp.h"
#include "gpiodriver.h"
#include "string.h"
#include "stdio.h"
#include "platform.h"

#include "location_and_navigation_db.h"
#include "location_and_navigation.h"
#include "bleappevent.h"

/******************************************************
 *                     Constants
 ******************************************************/

#define LOCATION_AND_NAVIGATION_FINE_TIMER           1000
#define LOCATION_AND_NAVIGATION_DEVICE_NAME          "BRCM LN"
#define LOCATION_AND_NAVIGATION_DEVICE_APPEARENCE    0
#define LOCATION_AND_NAVIGATION_MAIN_SERVICE_UUID    __UUID_LOCATION_AND_NAVIGATION
#define LOCATION_AND_NAVIGATION_MAIN_CHAR_UUID       __UUID_LOCATION_AND_NAVIGATION_LN_FEATURE
#define LOCATION_AND_NAVIGATION_MAIN_CHAR_HANDLE     HDLC_LOCATION_AND_NAVIGATION_LN_FEATURE_VALUE

/******************************************************
 *                     Structures
 ******************************************************/

#pragma pack(1)
//host information for NVRAM
typedef PACKED struct
{
    //part of HOSTINFO generated by wizard
    __HOSTINFO generated;
    // ToDo: add your variables here which need to be saved in the NVRAM
}  HOSTINFO;
#pragma pack()

/******************************************************
 *               Function Prototypes
 ******************************************************/

static void location_and_navigation_create(void);
static void location_and_navigation_connection_up( void );
static void location_and_navigation_connection_down( void );
static void location_and_navigation_advertisement_stopped( void );
static void location_and_navigation_smp_bond_result( LESMP_PARING_RESULT result );
static void location_and_navigation_encryption_changed( HCI_EVT_HDR *evt );
static int  location_and_navigation_write_handler( LEGATTDB_ENTRY_HDR *p );
static void location_and_navigation_interrupt_handler( UINT8 value );

static void location_and_navigation_DBInit(void);
static void location_and_navigation_handleUART(char *ln_char);
static int  location_and_navigation_checkClientConfigBeforeCP(void);
static int  location_and_navigation_send_delayed_indication(void* data);

static void location_and_navigation_navi_start_notification(void);
static void location_and_navigation_navi_stop_notification(void);

/******************************************************
 *               Variables Definitions
 ******************************************************/

const BLE_PROFILE_CFG location_and_navigation_cfg =
{
    /*.fine_timer_interval            =*/ LOCATION_AND_NAVIGATION_FINE_TIMER, // ms
    /*.default_adv                    =*/ 4,    // HIGH_UNDIRECTED_DISCOVERABLE
    /*.button_adv_toggle              =*/ 0,    // pairing button make adv toggle (if 1) or always on (if 0)
    /*.high_undirect_adv_interval     =*/ 32,   // slots
    /*.low_undirect_adv_interval      =*/ 1024, // slots
    /*.high_undirect_adv_duration     =*/ 30,   // seconds
    /*.low_undirect_adv_duration      =*/ 300,  // seconds
    /*.high_direct_adv_interval       =*/ 0,    // seconds
    /*.low_direct_adv_interval        =*/ 0,    // seconds
    /*.high_direct_adv_duration       =*/ 0,    // seconds
    /*.low_direct_adv_duration        =*/ 0,    // seconds
    /*.local_name                     =*/ LOCATION_AND_NAVIGATION_DEVICE_NAME, // [LOCAL_NAME_LEN_MAX];
    /*.cod                            =*/ BIT16_TO_8(LOCATION_AND_NAVIGATION_DEVICE_APPEARENCE),0x00, // [COD_LEN];
    /*.ver                            =*/ "1.00",         // [VERSION_LEN];
    /*.encr_required                  =*/ 0,    //(SECURITY_ENABLED | SECURITY_REQUEST),    // data encrypted and device sends security request on every connection
    /*.disc_required                  =*/ 0,    // if 1, disconnection after confirmation
    /*.test_enable                    =*/ 1,    // TEST MODE is enabled when 1
    /*.tx_power_level                 =*/ 0x04, // dbm
    /*.con_idle_timeout               =*/ 10,   // second  0-> no timeout
    /*.powersave_timeout              =*/ 0,    // second  0-> no timeout
    /*.hdl                            =*/ {LOCATION_AND_NAVIGATION_MAIN_CHAR_HANDLE, 0x00, 0x00, 0x00, 0x00}, // [HANDLE_NUM_MAX];
    /*.serv                           =*/ {LOCATION_AND_NAVIGATION_MAIN_SERVICE_UUID, 0x00, 0x00, 0x00, 0x00},
    /*.cha                            =*/ {LOCATION_AND_NAVIGATION_MAIN_CHAR_UUID, 0x00, 0x00, 0x00, 0x00},
    /*.findme_locator_enable          =*/ 0,    // if 1 Find me locator is enable
    /*.findme_alert_level             =*/ 0,    // alert level of find me
    /*.client_grouptype_enable        =*/ 0,    // if 1 grouptype read can be used
    /*.linkloss_button_enable         =*/ 0,    // if 1 linkloss button is enable
    /*.pathloss_check_interval        =*/ 0,    // second
    /*.alert_interval                 =*/ 0,    // interval of alert
    /*.high_alert_num                 =*/ 0,    // number of alert for each interval
    /*.mild_alert_num                 =*/ 0,    // number of alert for each interval
    /*.status_led_enable              =*/ 1,    // if 1 status LED is enable
    /*.status_led_interval            =*/ 0,    // second
    /*.status_led_con_blink           =*/ 0,    // blink num of connection
    /*.status_led_dir_adv_blink       =*/ 0,    // blink num of dir adv
    /*.status_led_un_adv_blink        =*/ 0,    // blink num of undir adv
    /*.led_on_ms                      =*/ 0,    // led blink on duration in ms
    /*.led_off_ms                     =*/ 0,    // led blink off duration in ms
    /*.buz_on_ms                      =*/ 100,  // buzzer on duration in ms
    /*.button_power_timeout           =*/ 0,    // seconds
    /*.button_client_timeout          =*/ 0,    // seconds
    /*.button_discover_timeout        =*/ 0,    // seconds
    /*.button_filter_timeout          =*/ 0,    // seconds
#ifdef BLE_UART_LOOPBACK_TRACE
    /*.button_uart_timeout            =*/ 15,   // seconds
#endif
};

// Following structure defines UART configuration
const BLE_PROFILE_PUART_CFG location_and_navigation_puart_cfg =
{
    /*.baudrate   =*/ 115200,
#ifdef GATT_DB_ENABLE_UART
    /*.txpin      =*/ GPIO_PIN_UART_TX,
    /*.rxpin      =*/ GPIO_PIN_UART_RX,
#else
    /*.txpin      =*/ PUARTDISABLE | GPIO_PIN_UART_TX,
    /*.rxpin      =*/ PUARTDISABLE | GPIO_PIN_UART_RX,
#endif
};

// NVRAM save area
HOSTINFO location_and_navigation_hostinfo;
//pointer to the generated part of hostinfo assuming it is the beginning of the hostinfo
__HOSTINFO *p_hostinfo_generated = &location_and_navigation_hostinfo.generated;

UINT16 	location_and_navigation_connection_handle      = 0;                  // HCI handle of connection, not zero when connected
BD_ADDR location_and_navigation_remote_addr            = {0, 0, 0, 0, 0, 0}; // Address of currently connected client

// ToDo: Add your static variables here
static UINT32 location_and_navigation_appfinetimer_count   = 0;
static UINT8  location_and_navigation_notification_enable  = 0;
static UINT8  location_and_navigation_measurement_done     = 0;

static UINT32       location_and_navigation_ln_feature;
static LN_LAS_DATA  location_and_navigation_las_data;
static UINT16       location_and_navigation_las_masked_flags;
static LN_PQ_DATA   location_and_navigation_pq_data;
static LN_NAVI_DATA location_and_navigation_navi_data;
static UINT16       location_and_navigation_navi_number_of_routes = 3;
static char         location_and_navigation_navi_names_of_routes[3][16] =
{
    "name#1",
    "name#2",
    "name#3"
};

/******************************************************
 *               Function Definitions
 ******************************************************/

// Application initialization
APPLICATION_INIT()
{
    bleapp_set_cfg((UINT8 *)gatt_database,
                   gatt_database_len,
                   (void *)&location_and_navigation_cfg,
                   (void *)&location_and_navigation_puart_cfg,
                   (void *)&location_and_navigation_gpio_cfg,
                   location_and_navigation_create);
}

// Create device
void location_and_navigation_create(void)
{
    extern UINT32 blecm_configFlag ;
    blecm_configFlag |= BLECM_DBGUART_LOG | BLECM_DBGUART_LOG_L2CAP | BLECM_DBGUART_LOG_SMP;
    lesmpkeys_removeAllBondInfo();

    ble_trace0("create()");
    ble_trace0(bleprofile_p_cfg->ver);

    // dump the database to debug uart.
    legattdb_dumpDb();

    bleprofile_Init(bleprofile_p_cfg);
    bleprofile_GPIOInit(bleprofile_gpio_p_cfg);

    location_and_navigation_DBInit();

    // Initialized ROM code which will monitor the battery
    blebat_Init();

    // Read NVRAM
    bleprofile_ReadNVRAM(VS_BLE_HOST_LIST, sizeof(location_and_navigation_hostinfo), (UINT8 *)&location_and_navigation_hostinfo);

    // register connection up and connection down handler.
    bleprofile_regAppEvtHandler(BLECM_APP_EVT_LINK_UP, location_and_navigation_connection_up);
    bleprofile_regAppEvtHandler(BLECM_APP_EVT_LINK_DOWN, location_and_navigation_connection_down);
    bleprofile_regAppEvtHandler(BLECM_APP_EVT_ADV_TIMEOUT, location_and_navigation_advertisement_stopped);

    // handler for Encryption changed.
    blecm_regEncryptionChangedHandler(location_and_navigation_encryption_changed);

    // handler for Bond result
    lesmp_regSMPResultCb((LESMP_SINGLE_PARAM_CB) location_and_navigation_smp_bond_result);

    // register to process client writes
    legattdb_regWriteHandleCb((LEGATTDB_WRITE_CB)location_and_navigation_write_handler);

    // register interrupt handler
    bleprofile_regIntCb((BLEPROFILE_SINGLE_PARAM_CB) location_and_navigation_interrupt_handler);

    //registers timer
    location_and_navigation_reg_timer();

    // advertise first vendor specific service
    if(sizeof(location_and_navigation_uuid_main_vsc_service) == 16)
    {
    	// total length should be less than 31 bytes
    	BLE_ADV_FIELD adv[3];

		// flags
		adv[0].len     = 1 + 1;
		adv[0].val     = ADV_FLAGS;
		adv[0].data[0] = LE_LIMITED_DISCOVERABLE | BR_EDR_NOT_SUPPORTED;

		adv[1].len     = 16 + 1;
		adv[1].val     = ADV_SERVICE_UUID128_COMP;
		memcpy(adv[1].data, &location_and_navigation_uuid_main_vsc_service[0], 16);

		// name
		adv[2].len      = strlen(bleprofile_p_cfg->local_name) + 1;
		adv[2].val      = ADV_LOCAL_NAME_COMP;
		memcpy(adv[2].data, bleprofile_p_cfg->local_name, adv[2].len - 1);

		bleprofile_GenerateADVData(adv, 3);
    }

    blecm_setTxPowerInADV(0);
    bleprofile_Discoverable(HIGH_UNDIRECTED_DISCOVERABLE, NULL);

    // ToDo: Do your initialization on app startup

    // start device advertisements.  By default Advertisements will contain flags, device name,
    // appearance and main service UUID.
}

// Connection up callback function is called on every connection establishment
void location_and_navigation_connection_up(void)
{
    UINT8 *bda = (UINT8 *)emconninfo_getPeerPubAddr();
	location_and_navigation_connection_handle = (UINT16)emconinfo_getConnHandle();

    // Save address of the connected device and print it out.
    memcpy(location_and_navigation_remote_addr, bda, sizeof(location_and_navigation_remote_addr));

    ble_trace3("connection_up: %08x%04x h=%d",
                (location_and_navigation_remote_addr[5] << 24) + (location_and_navigation_remote_addr[4] << 16) +
                (location_and_navigation_remote_addr[3] << 8) + location_and_navigation_remote_addr[2],
                (location_and_navigation_remote_addr[1] << 8) + location_and_navigation_remote_addr[0],
                location_and_navigation_connection_handle);


    // Prepare generated code for connection - write persistent values from __HOSTINFO to GATT DB
    __on_connection_up();

	// ToDo: Write custom persistent values into GATT database using functions
	// changed_<service_name>_<char_name>() generated by smart disigner
    location_and_navigation_las_masked_flags = location_and_navigation_las_data.flags;

    // If device supports a single connection, stop advertising
    bleprofile_Discoverable(NO_DISCOVERABLE, NULL);

    // If security is required for every connection following function will start bonding or
    // will setup encryption.  No indications or notifications should be sent until
    // encryption is not done.
    if (bleprofile_p_cfg->encr_required & SECURITY_REQUEST)
    	lesmp_sendSecurityRequest();
    else
    {
        location_and_navigation_notification_enable = 1;
        ble_trace0("Notification on\n");
    }
}

// Connection down callback
void location_and_navigation_connection_down(void)
{
    ble_trace1("connection_down:handle:%d", location_and_navigation_connection_handle);

    location_and_navigation_connection_handle = 0;
    location_and_navigation_notification_enable = 0;
    location_and_navigation_measurement_done    = 0;

    // If disconnection was caused by the peer, start low advertisements
    bleprofile_Discoverable(LOW_UNDIRECTED_DISCOVERABLE, NULL);

    ble_trace2("ADV start: %08x%04x",
                  (location_and_navigation_remote_addr[5] << 24 ) + (location_and_navigation_remote_addr[4] <<16) +
                  (location_and_navigation_remote_addr[3] << 8 ) + location_and_navigation_remote_addr[2],
                  (location_and_navigation_remote_addr[1] << 8 ) + location_and_navigation_remote_addr[0]);
}

// Callback function indicates to the application that advertising has stopped.
// restart advertisement if needed
void location_and_navigation_advertisement_stopped(void)
{
    ble_trace0("ADV stop!!!!");

	// If disconnection was caused by the peer, start low advertisements
    bleprofile_Discoverable(LOW_UNDIRECTED_DISCOVERABLE, NULL);
}

// Process SMP bonding result.  If pairing is successful with the central device,
// save its BDADDR in the NVRAM and initialize associated data
void location_and_navigation_smp_bond_result(LESMP_PARING_RESULT  result)
{
    ble_trace1("smp_bond_result %02x", result);

    if (result == LESMP_PAIRING_RESULT_BONDED)
    {
        // saving bd_addr in nvram
        UINT8 *bda;
        UINT8 writtenbyte;

        bda = (UINT8 *)emconninfo_getPeerPubAddr();

        // initialize persistent values in the hostinfo to add bonded peer
        location_and_navigation_add_bond(bda);

        // ToDo: initialize persistent variables in HOSTINFO

        //now write hostinfo into NVRAM
        writtenbyte = bleprofile_WriteNVRAM(VS_BLE_HOST_LIST, sizeof(location_and_navigation_hostinfo), (UINT8 *)&location_and_navigation_hostinfo);
        ble_trace1("NVRAM write:%04x", writtenbyte);
    }
}

// Notification from the stack that encryption has been set.
void location_and_navigation_encryption_changed(HCI_EVT_HDR *evt)
{
    UINT8 *bda = emconninfo_getPeerPubAddr();

    ble_trace2("encryption changed %08x%04x",
                (bda[5] << 24) + (bda[4] << 16) +
                (bda[3] << 8) + bda[2],
                (bda[1] << 8) + bda[0]);

    // ToDo: do your on-encryption-change actions here.

    // Slow down the pace of master polls to save power.  Following request asks
    // host to setup polling every 100-500 msec, with link supervision timeout 5 seconds.
    bleprofile_SendConnParamUpdateReq(80, 400, 0, 500);

    if (bleprofile_p_cfg->encr_required & SECURITY_REQUEST)
    {
        location_and_navigation_notification_enable = 1;
        ble_trace0("Notification on\n");
    }
}

// Process write request or command from peer device
int location_and_navigation_write_handler(LEGATTDB_ENTRY_HDR *p)
{
    UINT8  writtenbyte;
    UINT16 handle   = legattdb_getHandle(p);
    int    len      = legattdb_getAttrValueLen(p);
    UINT8  *attrPtr = legattdb_getAttrValue(p);
    BOOL changed = FALSE;
    int ret;

    ble_trace2("write_handler: handle %04x, len %04x", handle, len);

    ret = __write_handler(handle, len, attrPtr, &changed);

    // Save update to NVRAM if it has been changed.
    if (changed)
    {
		writtenbyte = bleprofile_WriteNVRAM(VS_BLE_HOST_LIST, sizeof(location_and_navigation_hostinfo), (UINT8 *)&location_and_navigation_hostinfo);
		ble_trace1("NVRAM write:%04x", writtenbyte);
    }
    return ret;
}

// Three Interrupt inputs (Buttons) can be handled here.
// If the following value == 1, Button is pressed. Different than initial value.
// If the following value == 0, Button is depressed. Same as initial value.
// Button1 : value&0x01
// Button2 : (value&0x02)>>1
// Button3 : (value&0x04)>>2
void location_and_navigation_interrupt_handler(UINT8 value)
{
    // ToDo: handle the interrupts here.
}

// Process indication confirmation.  if client service indication, each indication
// should be acknowledged before the next one can be sent.
void location_and_navigation_indication_cfm(void)
{
}

//------ generated code

// It will be called at the write handler and should return TRUE if any persistent value is changed
int on_write_location_and_navigation_ln_control_point(int len, UINT8 *attrPtr, BOOL *changed)
{
    //Todo: do you actions here when value is written by the peer
    // and return TRUE if any persistent value is changed
    LN_CP_HDR         *cpHdr = (LN_CP_HDR *) attrPtr ;
    BLEPROFILE_DB_PDU db_pdu;
    LN_CP_RSP_HDR     *cprspHdr = (LN_CP_RSP_HDR *)(db_pdu.pdu);
    UINT8             response;
    UINT8             length = 3; //default is 3

    if (location_and_navigation_checkClientConfigBeforeCP())
    {
        if (cpHdr->opcode == LN_CP_SET_CUMULATIVE_VALUE)
        {
            if (len != 4)
            {
                response = LN_CP_INVALID_PARAMETER;
            }
            else
            {
                UINT32 total_distance = cpHdr->parameter[0] + (cpHdr->parameter[1] << 8) + (cpHdr->parameter[2] << 16);
                memcpy((void *)&location_and_navigation_las_data.total_distance, (void *)&total_distance, 3);
                response = LN_CP_SUCCESS;
            }
        }
        else if (cpHdr->opcode == LN_CP_MASK_LOCATION_AND_SPEED_CHAR_CONTENT)
        {
            if (len < 3)
            {
                response = LN_CP_INVALID_PARAMETER;
            }
            else
            {
                UINT16 mask;

                mask = cpHdr->parameter[0] + (cpHdr->parameter[1] << 8);
                mask &= 0x007f;
                
                location_and_navigation_las_masked_flags &= ~mask;
                location_and_navigation_las_masked_flags |= (location_and_navigation_las_data.flags & (~mask & 0x007f));
                response = LN_CP_SUCCESS;
            }
        }
        else if (cpHdr->opcode == LN_CP_NAVIGATION_CONTROL)
        {
            if (len < 2)
            {
                response = LN_CP_INVALID_PARAMETER;
            }
            else
            {
                response = LN_CP_SUCCESS;

                switch(cpHdr->parameter[0])
                {
                    case 0x00:
                        /*
                        Stop Notification of the Navigation characteristic.
                        Stop Navigation
                        */
                        location_and_navigation_navi_stop_notification();
                        break;

                    case 0x01:
                        /*
                        Start Notification of the Navigation characteristic.
                        Start Navigation to the first waypoint on a route
                        */
                        location_and_navigation_navi_start_notification();
                        break;

                    case 0x02:
                        /*
                        Stop Notification of the Navigation characteristic.
                        Pause Navigation keeping the next waypoint on the route in the memory for continuing the navigation later
                        */
                        location_and_navigation_navi_stop_notification();
                        break;

                    case 0x03:
                        /*
                        Start Notification of the Navigation characteristic.
                        Continue Navigation from the point where navigation was paused to the next waypoint on the route
                        */
                        location_and_navigation_navi_start_notification();
                        break;

                    case 0x04:
                        /*
                        Notification of the Navigation characteristic not affected.
                        Skip Waypoint: disregard next waypoint and continue navigation to the waypoint following next waypoint on the route
                        */
                        break;

                    case 0x05:
                        /*
                        Start Notification of the Navigation characteristic.
                        Select Nearest Waypoint on a Route: measure the distance to all waypoints on the route,
                        and start navigation to the closest or optimal waypoint on the route (left to the implementation)
                        and from there to waypoints following next waypoint along the route
                        */
                        location_and_navigation_navi_start_notification();
                        break;

                    default:
                        response = LN_CP_INVALID_PARAMETER;
                        break;
                }
            }
        }
        else if (cpHdr->opcode == LN_CP_REQUEST_NUMBER_OF_ROUTES)
        {
            if (len < 1)
            {
                response = LN_CP_INVALID_PARAMETER;
            }
            else
            {
                cprspHdr->response_parameter[0] = location_and_navigation_navi_number_of_routes & 0xff;
                cprspHdr->response_parameter[1] = (location_and_navigation_navi_number_of_routes >> 8) & 0xff;
                length += 2;

                response = LN_CP_SUCCESS;
            }
        }
        else if (cpHdr->opcode == LN_CP_REQUEST_NAME_OF_ROUTE)
        {
            if (len < 3)
            {
                response = LN_CP_INVALID_PARAMETER;
            }
            else
            {
                UINT16 number_of_route = cpHdr->parameter[0] + (cpHdr->parameter[1] << 8);
                int i;

                for (i = 0; i < strlen(location_and_navigation_navi_names_of_routes[number_of_route]); i++)
                {
                    cprspHdr->response_parameter[i] = location_and_navigation_navi_names_of_routes[number_of_route][i];
                    length++;
                }

                response = LN_CP_SUCCESS;
            }
        }
        else if (cpHdr->opcode == LN_CP_SELECT_ROUTE)
        {
            if (len < 3)
            {
                response = LN_CP_INVALID_PARAMETER;
            }
            else
            {
                response = LN_CP_SUCCESS;
            }
        }
        else
        {
            // error response
            response = LN_CP_OPCODE_NOT_SUPPORTED;
        }

        // client char cfg is already checked

        cprspHdr->opcode         = LN_CP_RESPONSE_CODE;
        cprspHdr->request_opcode = cpHdr->opcode;
        cprspHdr->response_value = response;

        if (location_and_navigation_indication_sent == 0)
        {
            // some clients do not like if we send indication before write confirm.
           	// delay sending indication for later
           	BLEPROFILE_DB_PDU *p_db_pdu = (BLEPROFILE_DB_PDU *)cfa_mm_Alloc(sizeof(BLEPROFILE_DB_PDU));
            if (p_db_pdu != NULL)
            {
                location_and_navigation_indication_sent = 1;
                p_db_pdu->len = length < sizeof (p_db_pdu->pdu) ? length : sizeof (p_db_pdu->pdu);
                memcpy(p_db_pdu->pdu, cprspHdr, p_db_pdu->len);
                bleappevt_serialize(location_and_navigation_send_delayed_indication, p_db_pdu);
            }
        }
        else
        {
            ble_trace0("No Confirmation, Indication not sent");
            return LOCATION_AND_NAVIGATION_CP_PROCEDURE_ALREADY_IN_PROGRESS;
        }
    }
    else
    {
        return LOCATION_AND_NAVIGATION_CP_CLIENT_CHAR_CONF_IMPROPERLY;
    }

    return 0;
}

// It will be called every 1 sec
void location_and_navigation_timer_1s()
{
    //Todo: do you actions here every 1 second
    bleprofile_pollPowersave();
}

// It will be called every fine timer tick
void location_and_navigation_timer_fine()
{
    //Todo: do you actions here every fine timer tick
    char ln_char[READ_UART_LEN + 1];

    location_and_navigation_appfinetimer_count++;

    //Reading
    bleprofile_ReadUART(ln_char);
    //ble_trace6("UART RX: %02x %02x %02x %02x %02x %02x ",
    //      ln_char[0], ln_char[1], ln_char[2], ln_char[3], ln_char[4], ln_char[5]);

    location_and_navigation_handleUART(ln_char);
}

void location_and_navigation_DBInit(void)
{
    BLEPROFILE_DB_PDU db_pdu;
    
    bleprofile_ReadHandle(HDLC_LOCATION_AND_NAVIGATION_LN_FEATURE_VALUE, &db_pdu);
    memcpy((void *)&location_and_navigation_ln_feature, db_pdu.pdu, db_pdu.len);
    ble_trace1("%x", location_and_navigation_ln_feature);

    bleprofile_ReadHandle(HDLC_LOCATION_AND_NAVIGATION_LOCATION_AND_SPEED_VALUE, &db_pdu);
    memcpy((void *)&location_and_navigation_las_data, db_pdu.pdu, db_pdu.len);
    ble_tracen((char *)&location_and_navigation_las_data, db_pdu.len);
    
    bleprofile_ReadHandle(HDLC_LOCATION_AND_NAVIGATION_POSITION_QUALITY_VALUE, &db_pdu);
    memcpy((void *)&location_and_navigation_pq_data, db_pdu.pdu, db_pdu.len);
    ble_tracen((char *)&location_and_navigation_pq_data, db_pdu.len);

    bleprofile_ReadHandle(HDLC_LOCATION_AND_NAVIGATION_NAVIGATION_VALUE, &db_pdu);
    memcpy((void *)&location_and_navigation_navi_data, db_pdu.pdu, db_pdu.len);
    ble_tracen((char *)&location_and_navigation_navi_data, db_pdu.len);
}

void location_and_navigation_handleUART(char *ln_char)
{
    BLEPROFILE_DB_PDU db_pdu, db_cl_pdu;

    //This part can be replaced by callback function
    if (bleprofile_handleUARTCb)
    {
        location_and_navigation_measurement_done = bleprofile_handleUARTCb((UINT8 *)ln_char, (UINT8 *)&location_and_navigation_las_data);
    }
    else
    {
#if 1
        if (bleprofile_p_cfg->test_enable)
        {
            //This is making fake data
            //For test only
            UINT32 total_distance = 0;
            UINT32 remaining_distance = 0;
            UINT32 remaining_vertical_distance = 0;

            if (location_and_navigation_las_data.flags & LN_LAS_INSTANTANEOUS_SPEED_PRESENT)
            {
                location_and_navigation_las_data.instantaneous_speed = location_and_navigation_appfinetimer_count & 0x7f;
                //location_and_navigation_las_data.instantaneous_speed = 128;
            }

            if (location_and_navigation_las_data.flags & LN_LAS_TOTAL_DISTANCE_PRESENT)
            {
                memcpy((void *)&total_distance, (void *)&location_and_navigation_las_data.total_distance, 3);
                total_distance += (location_and_navigation_appfinetimer_count & 0x7f) / 10;
                //total_distance = 1024;
                memcpy((void *)&location_and_navigation_las_data.total_distance, (void *)&total_distance, 3);
            }

            if (location_and_navigation_pq_data.flags & LN_PQ_NUMBER_OF_BEACONS_IN_SOLUTION_PRESENT)
            {
                location_and_navigation_pq_data.number_of_beacons_in_solution = location_and_navigation_appfinetimer_count % 8;
            }

            if (location_and_navigation_pq_data.flags & LN_PQ_NUMBER_OF_BEACONS_IN_VIEW_PRESENT)
            {
                location_and_navigation_pq_data.number_of_beacons_in_view = location_and_navigation_appfinetimer_count % 10;
            }

            location_and_navigation_navi_data.bearing = 0;
            location_and_navigation_navi_data.heading = 0;

            if (location_and_navigation_navi_data.flags & LN_NAVI_REMAINING_DISTANCE_PRESENT)
            {
                memcpy((void *)&remaining_distance, (void *)&location_and_navigation_navi_data.remaining_distance, 3);
                remaining_distance = location_and_navigation_appfinetimer_count & 0xffff;
                memcpy((void *)&location_and_navigation_navi_data.remaining_distance, (void *)&remaining_distance, 3);
            }

            if (location_and_navigation_navi_data.flags & LN_NAVI_REMAINING_VERTICAL_DISTANCE_PRESENT)
            {
                memcpy((void *)&remaining_vertical_distance, (void *)&location_and_navigation_navi_data.remaining_vertical_distance, 3);
                remaining_vertical_distance = location_and_navigation_appfinetimer_count & 0xff;
                memcpy((void *)&location_and_navigation_navi_data.remaining_vertical_distance, (void *)&remaining_vertical_distance, 3);
            }

            location_and_navigation_measurement_done = 1; //New measurement is done
        }
#endif
    }

    // send Notification
    if (location_and_navigation_notification_enable && location_and_navigation_measurement_done)
    {
        int i;

        db_pdu.len = sizeof(location_and_navigation_las_data);
        memcpy(db_pdu.pdu, (void *)&location_and_navigation_las_data, db_pdu.len);
        bleprofile_WriteHandle(HDLC_LOCATION_AND_NAVIGATION_LN_FEATURE_VALUE, &db_pdu);
        ble_tracen((char *)db_pdu.pdu, db_pdu.len);
        
        db_pdu.len = sizeof(location_and_navigation_pq_data);
        memcpy(db_pdu.pdu, (void *)&location_and_navigation_pq_data, db_pdu.len);
        bleprofile_WriteHandle(HDLC_LOCATION_AND_NAVIGATION_POSITION_QUALITY_VALUE, &db_pdu);
        ble_tracen((char *)db_pdu.pdu, db_pdu.len);

        db_pdu.len = sizeof(location_and_navigation_navi_data);
        memcpy(db_pdu.pdu, (void *)&location_and_navigation_navi_data, db_pdu.len);
        bleprofile_WriteHandle(HDLC_LOCATION_AND_NAVIGATION_NAVIGATION_VALUE, &db_pdu);
        ble_tracen((char *)db_pdu.pdu, db_pdu.len);

        // Location and Navigation
        i = 0;

        // Mandatory items
        memcpy((void *)&(db_pdu.pdu[i]), (UINT8 *)&location_and_navigation_las_masked_flags, 2);
        i += 2;

        // Optional items
        if (location_and_navigation_las_masked_flags & LN_LAS_INSTANTANEOUS_SPEED_PRESENT)
        {
            memcpy((void *)&(db_pdu.pdu[i]), (void *)&location_and_navigation_las_data.instantaneous_speed, 2);
            i += 2;
        }

        if (location_and_navigation_las_masked_flags & LN_LAS_TOTAL_DISTANCE_PRESENT)
        {
            memcpy((void *)&(db_pdu.pdu[i]), (void *)&location_and_navigation_las_data.total_distance, 3);
            i += 3;
        }

        db_pdu.len = i;

        //check client char cfg
        bleprofile_ReadHandle(HDLD_LOCATION_AND_NAVIGATION_LOCATION_AND_SPEED_CLIENT_CONFIGURATION, &db_cl_pdu);
        ble_tracen((char *)db_cl_pdu.pdu, db_cl_pdu.len);

        if ((db_cl_pdu.len == 2) && (db_cl_pdu.pdu[0] & CCC_NOTIFICATION))
        {
            bleprofile_sendNotification(HDLC_LOCATION_AND_NAVIGATION_LOCATION_AND_SPEED_VALUE, db_pdu.pdu, db_pdu.len);
        }

        // Navigation
        i = 0;
        
        // Mandatory items
        memcpy((void *)&(db_pdu.pdu[i]), (UINT8 *)&location_and_navigation_navi_data.flags, 2);
        i += 2;

        memcpy((void *)&(db_pdu.pdu[i]), (UINT8 *)&location_and_navigation_navi_data.bearing, 2);
        i += 2;

        memcpy((void *)&(db_pdu.pdu[i]), (UINT8 *)&location_and_navigation_navi_data.heading, 2);
        i += 2;

        // Optional items
        if (location_and_navigation_navi_data.flags & LN_NAVI_REMAINING_DISTANCE_PRESENT)
        {
            memcpy((void *)&(db_pdu.pdu[i]), (void *)&location_and_navigation_navi_data.remaining_distance, 3);
            i += 3;
        }

        if (location_and_navigation_navi_data.flags & LN_NAVI_REMAINING_VERTICAL_DISTANCE_PRESENT)
        {
            memcpy((void *)&(db_pdu.pdu[i]), (void *)&location_and_navigation_navi_data.remaining_vertical_distance, 3);
            i += 3;
        }

        db_pdu.len = i;

        //check client char cfg
        bleprofile_ReadHandle(HDLD_LOCATION_AND_NAVIGATION_NAVIGATION_CLIENT_CONFIGURATION, &db_cl_pdu);
        ble_tracen((char *)db_cl_pdu.pdu, db_cl_pdu.len);

        if ((db_cl_pdu.len == 2) && (db_cl_pdu.pdu[0] & CCC_NOTIFICATION))
        {
            bleprofile_sendNotification(HDLC_LOCATION_AND_NAVIGATION_NAVIGATION_VALUE, db_pdu.pdu, db_pdu.len);
        }

        location_and_navigation_measurement_done = 0; //enable new measurement
    }
}

int location_and_navigation_checkClientConfigBeforeCP(void)
{
    BLEPROFILE_DB_PDU db_cl_pdu;
    bleprofile_ReadHandle (HDLD_LOCATION_AND_NAVIGATION_LN_CONTROL_POINT_CLIENT_CONFIGURATION, &db_cl_pdu);
    ble_tracen((char *)db_cl_pdu.pdu, db_cl_pdu.len);

    if ((db_cl_pdu.len == 2) && (db_cl_pdu.pdu[0] & CCC_INDICATION))
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

int location_and_navigation_send_delayed_indication(void* data)
{
	BLEPROFILE_DB_PDU *p_db_pdu = (BLEPROFILE_DB_PDU *)data;

	ble_tracen((char *)p_db_pdu->pdu, p_db_pdu->len);
	bleprofile_sendIndication(HDLC_LOCATION_AND_NAVIGATION_LN_CONTROL_POINT_VALUE, (UINT8 *)p_db_pdu->pdu, p_db_pdu->len, __indication_cfm);

	// See the note above the return value below.
	cfa_mm_Free(data);

	// Note: The serialized call should return either BLE_APP_EVENT_NO_ACTION or
	// BLE_APP_EVENT_FREE_BUFFER in which case the stack will free data
	// using cfa_mm_Free.
	// The other option in this function would be to return BLE_APP_EVENT_FREE_BUFFER
	// and remove the cfa_mm_Free call above.
	return BLE_APP_EVENT_NO_ACTION;
}

void location_and_navigation_navi_start_notification(void)
{
    BLEPROFILE_DB_PDU db_cl_pdu;

    bleprofile_ReadHandle(HDLD_LOCATION_AND_NAVIGATION_NAVIGATION_CLIENT_CONFIGURATION, &db_cl_pdu);

    db_cl_pdu.pdu[0] |= CCC_NOTIFICATION;

    bleprofile_WriteHandle(HDLD_LOCATION_AND_NAVIGATION_NAVIGATION_CLIENT_CONFIGURATION, &db_cl_pdu);

    if (__find_bonded_peer(location_and_navigation_remote_addr))
    {
        extern __HOSTINFO *p_bonded;
        UINT8 writtenbyte = 0;

        p_bonded->location_and_navigation_navigation_client_configuration = db_cl_pdu.pdu[0] + (db_cl_pdu.pdu[1] << 8);
        writtenbyte = bleprofile_WriteNVRAM(VS_BLE_HOST_LIST, sizeof(location_and_navigation_hostinfo), (UINT8 *)&location_and_navigation_hostinfo);
        ble_trace1("NVRAM write:%04x", writtenbyte);
    }
}

void location_and_navigation_navi_stop_notification(void)
{
    BLEPROFILE_DB_PDU db_cl_pdu;

    bleprofile_ReadHandle(HDLD_LOCATION_AND_NAVIGATION_NAVIGATION_CLIENT_CONFIGURATION, &db_cl_pdu);

    db_cl_pdu.pdu[0] &= ~CCC_NOTIFICATION;

    bleprofile_WriteHandle(HDLD_LOCATION_AND_NAVIGATION_NAVIGATION_CLIENT_CONFIGURATION, &db_cl_pdu);

    if (__find_bonded_peer(location_and_navigation_remote_addr))
    {
        extern __HOSTINFO *p_bonded;
        UINT8 writtenbyte = 0;

        p_bonded->location_and_navigation_navigation_client_configuration = db_cl_pdu.pdu[0] + (db_cl_pdu.pdu[1] << 8);
        writtenbyte = bleprofile_WriteNVRAM(VS_BLE_HOST_LIST, sizeof(location_and_navigation_hostinfo), (UINT8 *)&location_and_navigation_hostinfo);
        ble_trace1("NVRAM write:%04x", writtenbyte);
    }
}
